# Live Inspection UI

The `UInventoryRepresentationWidget` is a specialized UMG User Widget class designed to display the interactive 3D preview rendered by the PocketWorlds system and handle user input for manipulating that preview (rotation and zoom).

### Purpose

* **Display Render Target:** Shows the visual output from a `UPocketCapture` component (which renders the item staged by `APocketLevelStageManager`) within the UI.
* **Pocket World Integration:** Manages the lifecycle of a dedicated Pocket Level instance needed for the inspection, interacting with the `UPocketLevelBridgeSubsystem`.
* **Input Handling:** Captures mouse input (button presses, releases, movement, wheel scrolls) performed over the rendered image area.
* **Interaction Forwarding:** Relays processed input commands (rotation deltas, FOV changes) to the `APocketLevelStageManager` residing inside the pocket world.
* **Item Synchronization:** Initializes the inspection process for a specific `ULyraInventoryItemInstance` and can react to messages indicating the item's visuals have changed externally, triggering a refresh.

### Recommended UMG Setup

When creating a Blueprint widget derived from `UInventoryRepresentationWidget`, the typical structure includes:

1. **`RenderImage` (UMG Image Widget):**
   * **Binding:** Must be bound using `meta = (BindWidget)`.
   * **Purpose:** This is the core visual element where the 3D render will appear.
   * **Material:** Set its Brush Material to an instance of the `CameraRenderMaterial` (specified in the widget's properties). This material should be designed to sample two texture parameters, named "Diffuse" and "AlphaMask", which correspond to the render targets generated by `UPocketCapture`. The widget's code (`OnInventoryLevelReady`) will dynamically assign the correct `UTextureRenderTarget2D` assets to these parameters.
   * **Interaction:** Should have `Visibility` set to `Visible` or `Hit Test Invisible` (depending on whether the image itself or a container handles clicks). Needs `IsFocusable` potentially enabled if handling keyboard input. Bind `OnMouseButtonDownEvent` to `OnRenderImageButtonDown`.
2. **`RenderButtonContainer` (UMG Button Widget - Optional but Recommended):**
   * **Binding:** Bind using `meta = (BindWidget)` if used.
   * **Purpose:** An invisible or minimally styled Button placed visually _over_ the `RenderImage`. Buttons often provide more reliable capture for drag operations (press, hold, release) than Image widgets directly.
   * **Interaction:** Bind its `OnPressed` event to `OnRenderButtonPressed` and `OnReleased` to `OnRenderButtonReleased`. Set its `Click Method` property to `Mouse Down` in the UMG Editor details panel.

### Core Logic and Key Functions

* `NativePreConstruct()`**:** Sets the initial material (`CameraRenderMaterial`) on the `RenderImage`.
* **`NativeConstruct()`:**
  * Gets the `UPocketLevelBridgeSubsystem`.
  * Calls `SpawnPocketLevelWithUniqueID` on the bridge subsystem, using the `InventoryPocketLevelDefinition` specified in the widget's properties. This creates a _unique, private_ pocket world instance for this specific inspection widget. Stores the returned `PocketInstanceID`.
  * Initially streams the pocket level out (`StreamOutLevel`).
  * Gets the corresponding `UPocketLevelInstance` using the ID.
  * Registers a callback (`OnInventoryLevelReady`) for when the pocket level is fully loaded and visible using `AddReadyCallback`.
  * Starts streaming the pocket level in (`StreamIn`).
  * Binds the `OnPressed`/`OnReleased` delegates if `RenderButtonContainer` is used.
  * Binds the `RenderImage`'s `OnMouseButtonDownEvent` if needed (e.g., for right-click interaction).
* **`OnInventoryLevelReady(UPocketLevelInstance* Instance)`:**
  * This callback is executed _after_ the pocket level has finished loading and is visible.
  * Gets the `APocketLevelStageManager` associated with the `PocketInstanceID` via the bridge subsystem and stores a reference (`PocketLevelStageManager`).
  * Gets the `UPocketCapture` instance from the stage manager (`GetPocketCapture()`) and stores a reference (`PocketCaptureInstance`).
  * Gets the Dynamic Material Instance from the `RenderImage`.
  * Sets the `Diffuse` and `AlphaMask` texture parameters on the material, using the render targets obtained from `PocketCaptureInstance` (`GetOrCreateDiffuseRenderTarget`, `GetOrCreateAlphaMaskRenderTarget`).
  * If an `ItemInstance` has already been set via `InitialiseInspection`, it calls `PocketLevelStageManager->Initialise(ItemInstance)` to stage the item.
  * Calls `CaptureFrame()` to render the initial view.
  * Calls the Blueprint Native Event `InitialiseFinished()` to signal that the widget is fully set up and displaying the item.
* **`InitialiseInspection(ULyraInventoryItemInstance* InItemInstance)`:**
  * Called externally (e.g., by a parent inventory UI) to specify which item this widget should display.
  * Stores the `InItemInstance`.
  * If `PocketLevelStageManager` is already valid (meaning the level is ready), it immediately calls `PocketLevelStageManager->Initialise(ItemInstance)` to stage the new item. If the level isn't ready yet, `Initialise` will be called later within `OnInventoryLevelReady`.
  * Registers a listener for `TAG_Lyra_Inventory_Message_ItemVisualChange` using `UGameplayMessageSubsystem` to react to external changes requiring a re-render.
* **`OnItemVisualChangeMessage(FGameplayTag Channel, const FItemInstanceVisualChangeMessage& Payload)`:**
  * Handler for the visual change message.
  * If the `ItemInstance` in the message payload matches the one currently being displayed, it calls `PocketLevelStageManager->Initialise(ItemInstance)` again to refresh the staged mesh and attachments, ensuring the preview updates if, for example, an attachment was added externally.
* **Input Handling:**
  * `OnRenderButtonPressed()`: Sets `bIsRotating` to true, captures the initial mouse position (`LastMousePositionX`, `LastMousePositionY`).
  * `OnRenderButtonReleased()`: Sets `bIsRotating` to false. May optionally trigger `PocketLevelStageManager->ResetRotation()` if `bResetRotationOnLoseFocus` is configured on the item's `InventoryFragment_Inspect`.
  * `OnRenderImageButtonDown(...)`: Example implementation checks for Right Mouse Button to trigger `PocketLevelStageManager->ResetRotation(true)` and captures a new frame.
  * `NativeTick(...)`: If `bIsRotating` is true, calculates the mouse delta since the last tick, calls `PocketLevelStageManager->ManualRotation()` with the delta, updates the last mouse position, and calls `CaptureFrame()` to re-render.
  * `NativeOnMouseWheel(...)`: If `PocketLevelStageManager` is valid, calls `PocketLevelStageManager->SetFOV()` with the wheel delta and calls `CaptureFrame()` to re-render.
* **`CaptureFrame()`:** Simple helper function that calls `PocketCaptureInstance->CaptureDiffuse()` and `PocketCaptureInstance->CaptureAlphaMask()`. This triggers the rendering to the associated render targets. The `RenderImage` updates automatically as its material samples these changing textures.
* **`NativeDestruct()`:**
  * Unregisters the `ItemVisualChangeListener`.
  * Gets the `UPocketLevelBridgeSubsystem`.
  * If a valid `PocketInstanceID` exists, it gets the `UPocketLevelInstance`, removes the `OnInventoryLevelReady` callback handle.
  * Crucially, calls `BridgeSubsystem->DestroyPocketLevelInstance(PocketInstanceID)` to ensure the unique pocket world created for this widget instance is properly cleaned up and destroyed.
* **Blueprint Callables:**
  * `SetManualRotation(const FRotator& NewRotation)`: Allows setting the item's rotation directly via Blueprint.
  * `SetManualFOV(float FOV)`: Allows setting the camera FOV directly via Blueprint.
  * `InitialiseFinished()` (BlueprintNativeEvent): Can be implemented in Blueprint to perform actions after the pocket world is ready and the initial item is staged and rendered.

***

This widget acts as the crucial link between the UI layer and the hidden PocketWorlds rendering system for live previews. It orchestrates the complex process of loading the pocket world, initializing the staging manager with the correct item, displaying the rendered result, and translating user input into interactive controls for the 3D preview.
