# Broadcasting & Relaying Accolades

Previously, we saw how server-side **Gameplay Message Processors** (like `UEliminationChainProcessor`) detect complex gameplay events and translate them into specific accolade messages (e.g., broadcasting a `FLyraVerbMessage` with the `Verb` tag set to `Accolade.DoubleKill`).

However, simply broadcasting this message on the server isn't enough to display the accolade on the correct player's screen. The client-side UI (`UAccoladeHostWidget`) needs a specific type of notification (`FLyraNotificationMessage`) that is targeted directly to the player who earned the reward. This is where the **`UAccoladeRelay`** comes in.

### The Need for Relaying

The processors generate authoritative signals that an accolade condition has been met. The UI needs a filtered, targeted signal to react appropriately. The `UAccoladeRelay` acts as this crucial bridge:

1. **Listens:** It subscribes to the Gameplay Messages generated by the various processors that signal an awarded accolade.
2. **Identifies Target:** It extracts the `Instigator` (the player who earned the accolade) from the incoming message.
3. **Translates:** It converts the generic accolade message (`FLyraVerbMessage`) into the specific `FLyraNotificationMessage` format expected by the UI display system.
4. **Delivers:** It ensures this notification message is delivered only to the relevant player(s).

### `UAccoladeRelay`

This `UGameplayMessageProcessor` subclass is dedicated to relaying accolade events to the appropriate clients for UI display.

```cpp
// Relays the accolades to the player
UCLASS(Blueprintable, BlueprintType)
class UAccoladeRelay : public UGameplayMessageProcessor
{
    GENERATED_BODY()

public:
    virtual void StartListening() override;

private:
    UFUNCTION()
    void OnAccoladeMessage(FGameplayTag Channel, const FLyraVerbMessage& Payload);
};
```

**Role:** Its sole purpose is to listen for messages indicating an accolade has been earned and forward that information in the correct format (`FLyraNotificationMessage`) to the player who earned it. Like other processors, it typically resides as a component on the GameState and runs on the server/host.

**1. Listening (`StartListening`)**

The relay subscribes to a specific Gameplay Message channel designated for accolade events.

```cpp
// Tag definition used by the relay listener
UE_DEFINE_GAMEPLAY_TAG_STATIC(TAG_Lyra_Accolodate_Message, "ShooterGame.Accolade");
// Tag definition used for broadcasting the notification message
UE_DEFINE_GAMEPLAY_TAG_STATIC(TAG_Lyra_Notification_Message, "Lyra.AddNotification.Message");

void UAccoladeRelay::StartListening()
{
    UGameplayMessageSubsystem& MessageSubsystem = UGameplayMessageSubsystem::Get(this);
    // Listens for messages broadcast on the "ShooterGame.Accolade" channel
    AddListenerHandle(MessageSubsystem.RegisterListener(TAG_Lyra_Accolodate_Message, this, &ThisClass::OnAccoladeMessage));
}
```

* It listens on the `ShooterGame.Accolade` channel. This implies that the upstream processors (like Chain, Streak, Assist) should ideally broadcast their specific accolade `FLyraVerbMessage` instances onto this `ShooterGame.Accolade` channel, using their specific tags (e.g., `Accolade.DoubleKill`) within the message's `Verb` field. _(Note: The provided processor code broadcasts directly on the Verb tag channel; ensure consistency in your implementation or adjust the relay's listening tags if needed)._

**2. Processing (`OnAccoladeMessage`)**

This function is executed when a message arrives on the `ShooterGame.Accolade` channel.

```cpp
void UAccoladeRelay::OnAccoladeMessage(FGameplayTag Channel, const FLyraVerbMessage& Payload)
{
    // Ensure running on the authority (Server/Host)
    if (!IsNetSimulating())
    {
        // Get the PlayerState of the person who earned the accolade
        if (APlayerState* InstigatorPS = ULyraVerbMessageHelpers::GetPlayerStateFromObject(Payload.Instigator))
        {
            // Use Lyra's system to potentially send the raw verb message to the client
            if(ALyraPlayerState* LyraPlayerState = Cast<ALyraPlayerState>(InstigatorPS))
            {
                LyraPlayerState->ClientBroadcastMessage(Payload);
            }

            // --- Prepare and broadcast the UI Notification ---
            // Check if we are NOT a dedicated server (i.e., Listen Server or Standalone Client)
            if(!UKismetSystemLibrary::IsDedicatedServer(GetWorld()))
            {
                // Construct the notification message for the UI
                FLyraNotificationMessage AccoladeMessage;
                AccoladeMessage.TargetChannel = TAG_Lyra_Accolodate_Message; // TargetChannel for filtering in AccoladeHostWidget
                AccoladeMessage.TargetPlayer = InstigatorPS; // Target this specific player's UI
                AccoladeMessage.PayloadTag = Payload.Verb; // The specific accolade (e.g., Accolade.DoubleKill)

                // Broadcast the notification message locally on the "Lyra.AddNotification.Message" channel
                UGameplayMessageSubsystem& MessageSubsystem = UGameplayMessageSubsystem::Get(this);
                MessageSubsystem.BroadcastMessage(TAG_Lyra_Notification_Message, AccoladeMessage);
            }
        }
    }
}
```

**Key Steps in `OnAccoladeMessage`:**

1. **Authority Check:** `!IsNetSimulating()` ensures this logic only runs on the server/host.
2. **Get Instigator:** Retrieves the `APlayerState` (`InstigatorPS`) of the player who performed the action from the `Payload.Instigator`.
3. **`ClientBroadcastMessage` (Lyra Feature):** It calls `ClientBroadcastMessage` on the instigator's `ALyraPlayerState`. This is likely used by the Lyra framework to send the original `FLyraVerbMessage` (`Payload`) reliably to the specific client associated with `InstigatorPS`. This raw message might be used by other client-side systems. Crucially, it's assumed that the implementation of `ClientBroadcastMessage` (or subsequent handling on the client) **also results in the necessary `FLyraNotificationMessage` being broadcast locally on that specific client**, ensuring the UI receives the notification even when running on a dedicated server.
4. **Local Notification (Non-Dedicated Server):** If the game is _not_ running on a dedicated server (meaning it's a listen server or standalone), the relay _also_ directly constructs and broadcasts the `FLyraNotificationMessage` using the local `GameplayMessageSubsystem`. This ensures the host player's UI gets the notification immediately.
5. **`FLyraNotificationMessage` Construction:**
   * `TargetChannel`: Set to `TAG_Lyra_Accolodate_Message` (`ShooterGame.Accolade`). The `UAccoladeHostWidget` will check this field to ensure it's processing the right type of notification.
   * `TargetPlayer`: Set to `InstigatorPS`. The `UAccoladeHostWidget` checks this to ensure it only displays accolades intended for the owning player.
   * `PayloadTag`: Set to `Payload.Verb`. This carries the specific Gameplay Tag of the accolade being awarded (e.g., `Accolade.DoubleKill`, `Accolade.Assist`), which the `UAccoladeHostWidget` uses to look up the definition in the Data Registry.
6. **Broadcasting the Notification:** The constructed `AccoladeMessage` is broadcast on the `TAG_Lyra_Notification_Message` (`Lyra.AddNotification.Message`) channel. The `UAccoladeHostWidget` listens on this specific channel.

### Summary of Relay Flow

1. A server-side Processor (e.g., `UEliminationChainProcessor`) detects an event and broadcasts a `FLyraVerbMessage` (e.g., with `Verb = Accolade.DoubleKill`) onto the `ShooterGame.Accolade` channel (ideally).
2. The `UAccoladeRelay` (on the server) receives this message via its listener.
3. The Relay identifies the `InstigatorPS`.
4. The Relay ensures a `FLyraNotificationMessage` (containing `TargetPlayer = InstigatorPS` and `PayloadTag = Accolade.DoubleKill`) is broadcast locally on the `Lyra.AddNotification.Message` channel _on the target player's client_.
   * On Listen Servers/Standalone: Done directly by the Relay.
   * On Dedicated Servers: Assumed to be handled via the `ClientBroadcastMessage` mechanism triggering a similar local broadcast on the receiving client.
5. The target player's `UAccoladeHostWidget` receives this specific, targeted notification, ready to process and display the accolade.

The `UAccoladeRelay` acts as the essential link ensuring that server-detected achievements are correctly and efficiently translated into UI notifications for the deserving player. The next section details how the client-side `UAccoladeHostWidget` handles these notifications.

***
