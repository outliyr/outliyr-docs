---
description: 'Cosmetics: Core Data Structures'
---

# Core Data Structures

The cosmetic system relies on several key `USTRUCT`s to define cosmetic parts, manage their application state, and track them across different components. Understanding these structures is essential for working with the system's APIs and data flow.

### `FLyraCharacterPart`

This is the fundamental structure used to **request** a specific cosmetic part to be applied. It defines what should be spawned and how it should be attached.

```cpp
USTRUCT(BlueprintType)
struct FLyraCharacterPart
{
    GENERATED_BODY()

    // The Actor class to spawn as the visual representation of this part.
    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    TSubclassOf<AActor> PartClass;

    // The name of the socket (on the attachment parent, usually a Skeletal Mesh)
    // where the spawned Actor should be attached. Use NAME_None for root component attachment.
    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    FName SocketName;

    // Determines how collision should be configured on the spawned Actor instance.
    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    ECharacterCustomizationCollisionMode CollisionMode = ECharacterCustomizationCollisionMode::NoCollision;

    // Helper function to compare if two parts are functionally the same
    // (same class and socket), ignoring the collision setting which might vary.
    static bool AreEquivalentParts(const FLyraCharacterPart& A, const FLyraCharacterPart& B);
};
```

* **`PartClass`:** Crucially defines what Actor represents this cosmetic piece. This Actor should contain the necessary visual components (Static Mesh, Skeletal Mesh, Particle System, etc.).
* **`SocketName`:** Specifies where on the parent Pawn (usually its Skeletal Mesh) this part should attach. If `NAME_None` or invalid, it might attach to the root component.
* **`CollisionMode`:** Controls whether the spawned part actor should have collision enabled (`UseCollisionFromCharacterPart`) or disabled (`NoCollision`). This is useful for preventing cosmetic items from interfering with gameplay physics unless explicitly intended.
* **Usage:** This structure is passed into `ULyraControllerComponent_CharacterParts::AddCharacterPart` and `ULyraPawnComponent_CharacterParts::AddCharacterPart` to initiate the process of applying a cosmetic.

### `FLyraCharacterPartHandle`

This structure acts as a unique identifier for a character part instance that has been successfully applied by the `ULyraPawnComponent_CharacterParts`.

```cpp
USTRUCT(BlueprintType)
struct FLyraCharacterPartHandle
{
    GENERATED_BODY()

    void Reset(); // Sets the handle to an invalid state (INDEX_NONE)
    bool IsValid() const; // Checks if the handle is valid

private:
    // Internal index used for tracking. Not intended for direct manipulation.
    UPROPERTY()
    int32 PartHandle = INDEX_NONE;

    // Grant friendship so the list can manage handles internally.
    friend FLyraCharacterPartList;
};
```

* **Purpose:** When the server-side `ULyraPawnComponent_CharacterParts` successfully processes an `AddCharacterPart` request (via `FLyraCharacterPartList::AddEntry`), it generates a unique handle (using an internal counter `PartHandleCounter`).
* **Return Value:** This handle is returned to the caller (typically the `ULyraControllerComponent_CharacterParts`).
* **Usage:** The `ULyraControllerComponent_CharacterParts` stores this handle alongside its `FLyraCharacterPart` request. When it needs to remove a specific part instance (e.g., on unpossession or explicit removal), it passes this handle back to the `ULyraPawnComponent_CharacterParts::RemoveCharacterPart` function, allowing the Pawn component to identify and remove the correct entry from its list.
* **State:** `IsValid()` checks if the handle represents a currently tracked part instance. `Reset()` invalidates the handle.

### `FLyraAppliedCharacterPartEntry` (Internal to Pawn Component)

This structure represents a single applied character part within the `FLyraCharacterPartList` managed by the `ULyraPawnComponent_CharacterParts`. It combines the original request with runtime state information.

```cpp
USTRUCT()
struct FLyraAppliedCharacterPartEntry : public FFastArraySerializerItem
{
    GENERATED_BODY()
    // ... constructor, GetDebugString ...
private:
    friend FLyraCharacterPartList;
    friend ULyraPawnComponent_CharacterParts;

    // The original definition/request for this part.
    UPROPERTY()
    FLyraCharacterPart Part;

    // The unique handle generated by the server for this specific instance.
    // Not replicated, as handles are only relevant server-side for removal requests.
    UPROPERTY(NotReplicated)
    int32 PartHandle = INDEX_NONE;

    // Pointer to the spawned UChildActorComponent instance representing this part visually.
    // Client-only (and non-replicated), as components are spawned locally based on replicated data.
    UPROPERTY(NotReplicated)
    TObjectPtr<UChildActorComponent> SpawnedComponent = nullptr;
};
```

* **`FFastArraySerializerItem`:** Inherits from this base to integrate with the `FFastArraySerializer` system used by `FLyraCharacterPartList`.
* **`Part`:** Stores the original `FLyraCharacterPart` definition (Class, Socket, Collision). This data is replicated as part of the list entry.
* **`PartHandle`:** Stores the server-generated handle. Marked NotReplicated as it's only needed for the server to process removal requests via the handle.
* **`SpawnedComponent`:** Holds a pointer to the `UChildActorComponent` that was created locally (on clients and the server) to represent this part. Marked NotReplicated because components cannot be directly replicated this way; clients spawn their own based on the replicated Part data.
* **Role:** This is the internal data unit within the replicated array on the Pawn component, tracking both the definition and the runtime state (spawned component pointer) of each applied cosmetic.

### `FLyraControllerCharacterPartEntry` (Internal to Controller Component)

This structure represents a single desired character part within the list managed by the `ULyraControllerComponent_CharacterParts`.

```cpp
USTRUCT()
struct FLyraControllerCharacterPartEntry
{
    GENERATED_BODY()
    // ... constructor ...
public:
    // The definition of the desired part.
    UPROPERTY(EditAnywhere, meta=(ShowOnlyInnerProperties))
    FLyraCharacterPart Part;

    // The handle received from the Pawn component once this part is successfully applied.
    // Used to request removal later. Resets on unpossession.
    FLyraCharacterPartHandle Handle;

    // Tracks why this part was added (Natural gameplay, Cheat, Developer Setting).
    ECharacterPartSource Source = ECharacterPartSource::Natural;
};
```

* **`Part`:** Stores the `FLyraCharacterPart` definition that this Controller wants applied.
* **`Handle`:** Temporarily stores the `FLyraCharacterPartHandle` received from the Pawn component when the part is successfully applied to the currently possessed Pawn. This is used to tell the Pawn component which specific instance to remove later. It's reset when the Pawn changes.
* **`Source`:** Tracks the origin of the part request, used for managing cheat overrides and cleanup.
* **Role:** This is the internal data unit within the Controller component's list, representing the persistent cosmetic choices for that controller.

### `ECharacterCustomizationCollisionMode` (Enum)

A simple enumeration used within `FLyraCharacterPart` to specify the desired collision behavior for the spawned part actor.

```cpp
UENUM()
enum class ECharacterCustomizationCollisionMode : uint8
{
    // Disable collision entirely on the spawned part actor instance.
    NoCollision,

    // Do not modify the collision settings; use whatever is defined
    // in the PartClass Actor's components.
    UseCollisionFromCharacterPart
};
```

### Summary

These data structures form the backbone of the cosmetic system:

* `FLyraCharacterPart` defines the request.
* `FLyraCharacterPartHandle` identifies an applied instance for removal.
* `FLyraAppliedCharacterPartEntry` tracks the runtime state on the Pawn (replicated definition + local component pointer).
* `FLyraControllerCharacterPartEntry` tracks the desired state on the Controller (definition + source + temporary handle).
* `ECharacterCustomizationCollisionMode` configures collision behavior.

Understanding these structs clarifies how information flows between the Controller and Pawn components and how cosmetic parts are defined and managed.

***

Next, we can explore **Animation & Body Style Integration**.
