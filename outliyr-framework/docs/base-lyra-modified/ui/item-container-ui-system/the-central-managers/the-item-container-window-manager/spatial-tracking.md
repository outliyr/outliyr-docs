# Spatial Tracking

The fundamental limitation of UMG's `CanvasPanel` is that it doesn't provide an easy way to query "What is next to me?". To solve this, the Window Manager maintains a shadow copy of the layout logic.

### The Data Structure

Every window is tracked using a lightweight struct, `FRegisteredItemContainerWindow`.

```cpp
struct FRegisteredItemContainerWindow
{
    /** The navigation brain for this window */
    TWeakObjectPtr<ULyraNavigationRouter> Router;

    /** Root widget (for focus management) */
    TWeakObjectPtr<UWidget> RootWidget;

    /** 
     * Current screen-space bounding rect.
     * Stored as (Left, Top, Right, Bottom).
     * Updated every time the user drags or resizes the window.
     */
    FVector4 GeometryRect; 

    /** Last time this window was focused (for Z-Order sorting) */
    double LastFocusedTime;
};
```

This struct allows us to perform geometric queries without touching the UWidget hierarchy, which is safer for threading and performance.

### Registration

When a new window opens, the `LyraItemContainerWindowShell` automatically calls `RegisterWindow`:

```cpp
void ULyraItemContainerWindowManager::RegisterWindow(FGuid WindowId, ULyraNavigationRouter* Router, UWidget* RootWidget)
{
    FRegisteredItemContainerWindow WindowData;
    WindowData.Router = Router;
    WindowData.RootWidget = RootWidget;
    
    // Add to the map
    RegisteredWindows.Add(WindowId, WindowData);
    
    // Auto-focus if it's the first window
    if (!FocusedWindowId.IsValid())
    {
        SetFocusedWindow(WindowId);
    }
}
```

We use a `FGuid` as the handle. This ID is generated by the Shell when it is initialized and remains constant for the lifetime of that window instance.

### Geometry Updates (`UpdateWindowGeometry`)

Windows move. A lot. When a user drags a window, the visual position changes every frame.

The **Shell** (or the Layer hosting it) is responsible for reporting these changes. In `UpdateWindowDrag`, after setting the Canvas Slot position, the Layer calls:

```cpp
void ULyraItemContainerLayer::UpdateWindowGeometry(FItemWindowHandle WindowHandle)
{
    // 1. Get the actual Slate geometry from the widget
    const FGeometry& Geom = Shell->GetCachedGeometry();
    
    // 2. Convert to Absolute Screen Coordinates
    FVector2D AbsPos = Geom.GetAbsolutePosition();
    FVector2D AbsSize = Geom.GetAbsoluteSize();

    // 3. Report to Window Manager
    WindowManager->UpdateWindowGeometry(
        WindowHandle.WindowId,
        FVector4(AbsPos.X, AbsPos.Y, AbsPos.X + AbsSize.X, AbsPos.Y + AbsSize.Y)
    );
}
```

**Critical Detail: Absolute Coordinates** We always store **Absolute Screen Space** coordinates.

* Widgets inside a window use _Window-Local_ coordinates.
* The Window Manager uses _Global_ coordinates.

This normalization is what allows us to mathematically compare Window A (top-left) with Window B (bottom-right) to determine if they are neighbors.

### Cleanup

The Manager holds `TWeakObjectPtr` to the Router and Widget. If a window is destroyed without unregistering (e.g., hard level transition), the pointers become stale.

We implement a lazy cleanup pattern in `CleanupStaleWindows`. Before performing any expensive operation (like navigation search), we iterate the map and remove any entries where `Router.IsValid()` returns false. This prevents the system from trying to navigate to a dead window.
